#ifndef sheet_h_fhasdufhqweioq34ryh8iouertgfhouiaerfghiouerwfghuio
#define sheet_h_fhasdufhqweioq34ryh8iouertgfhouiaerfghiouerwfghuio
namespace Pikachu
{
	struct NetL
	{
		enum regular
		{
			_id_ = 1,
			_integer_ = 2,
			_realC_ = 3,
			_string_ = 4,
			_header_ = 5,
			_include_ = 6,
			_forward_ = 7,
			_backward_ = 8,
			_sum_ = 9,
			_func_ = 10,
			_net_ = 11,
			_tensor_ = 12,
			_def_ = 13,
			_input_ = 14,
			_output_ = 15,
			_para_ = 16,
			_return_ = 17,
			_for_ = 18,
			_if_ = 19,
			_else_ = 20,
			_real_ = 21,
			_complex_ = 22,
			_sint_ = 23,
			_uint_ = 24,
			_bool_ = 25,
			_sin_ = 26,
			_cos_ = 27,
			_exp_ = 28,
			_ln_ = 29,
			_log_ = 30,
			_sqrt_ = 31,
			_pow_ = 32,
			_spaces_ = 33,
			_enters_ = 34,
			_tab_ = 35,
			_semicolon_ = 36,
			_colon_ = 37,
			_dot_ = 38,
			_comma_ = 39,
			_braceL_ = 40,
			_braceR_ = 41,
			_left_ = 42,
			_right_ = 43,
			_squareL_ = 44,
			_squareR_ = 45,
			_angleL_ = 46,
			_angleR_ = 47,
			_anntationS_ = 48,
			_anntationM_ = 49,
			_multi_ = 50,
			_div_ = 51,
			_sub_ = 52,
			_add_ = 53,
			_assign_ = 54
		};
		enum group
		{
			_id___ = 1,
			_number___ = 2,
			_string___ = 3,
			_macro___ = 4,
			_instruct___ = 5,
			_reserved___ = 6,
			_type___ = 7,
			_function1___ = 8,
			_function2___ = 9,
			_format___ = 10,
			_division___ = 11,
			_braket___ = 12,
			_anntation___ = 13,
			_operatmd___ = 14,
			_operatas___ = 15,
			_assignments___ = 16
		};
		static int next(int state, const char c);
		static int action(int state);
		static int GroupGet(int state);
	};
	struct NetG
	{
		enum type
		{
			accept = 0,
			error = 1,
			push = 2,
			reduce = 3
		};
		enum rules
		{
			all_all_ = 0,
			context_defs_ = 1,
			//<DEF*>_first_ = 2,
			//<DEF*>_multi_ = 3,
			DEF_symbolic_ = 4,
			DEF_network_ = 5,
			DEF_def_ = 6,
			DEF_exp_ = 7,
			DEF_diff_ = 8,
			OPERATOR_operatmd_ = 9,
			OPERATOR_operatas_ = 10,
			//[operatmd]_multi_ = 11,
			//[operatmd]_div_ = 12,
			//[operatas]_sub_ = 13,
			//[operatas]_add_ = 14,
			DIFF_NET_diff_ = 15,
			DIFF_INSTR_forward_ = 16,
			DIFF_INSTR_backward_ = 17,
			ID_LISTSQUARE_ID_LISTSQUARE_ = 18,
			ID_LIST_single_ = 19,
			ID_LIST_multi_ = 20,
			EXP_RIGHT_default_ = 21,
			EXP_RIGHT_add_ = 22,
			EXP_MUL_default_ = 23,
			EXP_MUL_multi_ = 24,
			EXP_MINUS_default_ = 25,
			EXP_MINUS_plus_ = 26,
			UNIT_id_ = 27,
			UNIT_call_ = 28,
			UNIT_const_ = 29,
			UNIT_complex_ = 30,
			//[number]_integer_ = 31,
			//[number]_realC_ = 32,
			ID_array_ = 33,
			ID_single_ = 34,
			INDEX_COMPUTE_single_ = 35,
			CALL_call_1_ = 36,
			CALL_call_2_ = 37,
			//[function1]_sin_ = 38,
			//[function1]_cos_ = 39,
			//[function1]_exp_ = 40,
			//[function1]_ln_ = 41,
			//[function1]_log_ = 42,
			//[function1]_sqrt_ = 43,
			//[function2]_pow_ = 44,
			SYMBOLIC_SYMBOLIC_ = 45,
			PARA_PARA_ = 46,
			//<SYMBOLICPARAS>_single_ = 47,
			//<SYMBOLICPARAS>_multi_ = 48,
			SYMBOLICPARA_input_ = 49,
			SYMBOLICPARA_para_ = 50,
			SYMBOLICPARA_output_ = 51,
			SYMBOLICBODY_SYMBOLICBODY_ = 52,
			//<STATEMENT*>_first_ = 53,
			//<STATEMENT*>_multi_ = 54,
			STATEMENT_const_ = 55,
			STATEMENT_def1_ = 56,
			STATEMENT_def2_ = 57,
			STATEMENT_exp_ = 58,
			CONSTVAR_def1_ = 59,
			CONSTVAR_def2_ = 60,
			//[type]_real_ = 61,
			//[type]_complex_ = 62,
			//[type]_sint_ = 63,
			//[type]_uint_ = 64,
			//[type]_bool_ = 65,
			VALUE_single_ = 66,
			VALUE_multi_ = 67,
			VALUELIST_VALUELIST_ = 68,
			VALUES_VALUES_ = 69,
			//<NEXTVALUE*>_first_ = 70,
			//<NEXTVALUE*>_multi_ = 71,
			NEXTVALUE_NEXTVALUE_ = 72,
			NETWORK_NETWORK_ = 73,
			NETBODY_net_ = 74,
			//<NET_STATEMENT*>_first_ = 75,
			//<NET_STATEMENT*>_multi_ = 76,
			NET_STATEMENT_const_ = 77,
			NET_STATEMENT_exp_ = 78,
			NET_STATEMENT_def_ = 79,
			NET_STATEMENT_tensorDef1_ = 80,
			NET_STATEMENT_tensorDef2_ = 81,
			TENSORID_TENSORID_ = 82,
			TENSOR_TENSOR_ = 83,
			INDEXLIST_INDEXLIST_ = 84,
			INDEXUNITS_single_ = 85,
			INDEXUNITS_multi_ = 86,
			ID2_yes_ = 87,
			ID2_no_ = 88,
			TENSORVALUE_single_ = 89,
			TENSORVALUE_single1_ = 90,
			TENSORVALUE_multi_ = 91,
			TENSORVALUE_singleF_ = 92,
			TENSORVALUE_multiF_ = 93,
			SUMSYMBOL_single_ = 94,
			SUMSYMBOL_multi_ = 95,
			SQ_INDEXUNITS_single_ = 96
		};
		enum nonterminal
		{
			_all_ = 0,
			_context_ = 1,
			//_<DEF*>_ = 2,
			_DEF_ = 3,
			_OPERATOR_ = 4,
			//_[operatmd]_ = 5,
			//_[operatas]_ = 6,
			_DIFF_NET_ = 7,
			_DIFF_INSTR_ = 8,
			_ID_LISTSQUARE_ = 9,
			_ID_LIST_ = 10,
			_EXP_RIGHT_ = 11,
			_EXP_MUL_ = 12,
			_EXP_MINUS_ = 13,
			_UNIT_ = 14,
			//_[number]_ = 15,
			_ID_ = 16,
			_INDEX_COMPUTE_ = 17,
			_CALL_ = 18,
			//_[function1]_ = 19,
			//_[function2]_ = 20,
			_SYMBOLIC_ = 21,
			_PARA_ = 22,
			//_<SYMBOLICPARAS>_ = 23,
			_SYMBOLICPARA_ = 24,
			_SYMBOLICBODY_ = 25,
			//_<STATEMENT*>_ = 26,
			_STATEMENT_ = 27,
			_CONSTVAR_ = 28,
			//_[type]_ = 29,
			_VALUE_ = 30,
			_VALUELIST_ = 31,
			_VALUES_ = 32,
			//_<NEXTVALUE*>_ = 33,
			_NEXTVALUE_ = 34,
			_NETWORK_ = 35,
			_NETBODY_ = 36,
			//_<NET_STATEMENT*>_ = 37,
			_NET_STATEMENT_ = 38,
			_TENSORID_ = 39,
			_TENSOR_ = 40,
			_INDEXLIST_ = 41,
			_INDEXUNITS_ = 42,
			_ID2_ = 43,
			_TENSORVALUE_ = 44,
			_SUMSYMBOL_ = 45,
			_SQ_INDEXUNITS_ = 46
		};
		static const size_t StateCount;
		static const size_t NonTerminalCount;
		static const size_t TerminalCount;
		static const size_t RulesCount;
		static const int GOTO[189][47];
		static const int ACTION[189][55];
		static const int RulesToSymbol[97];
		static const int RulesLength[97];
		static const char* const RulesName[97];
		static const int Implicit[97];
	};
	struct NetPreL
	{
		enum regular
		{
			_id_ = 1,
			_integer_ = 2,
			_realC_ = 3,
			_string_ = 4,
			_header_ = 5,
			_include_ = 6,
			_forward_ = 7,
			_backward_ = 8,
			_sum_ = 9,
			_func_ = 10,
			_net_ = 11,
			_tensor_ = 12,
			_def_ = 13,
			_input_ = 14,
			_output_ = 15,
			_para_ = 16,
			_return_ = 17,
			_for_ = 18,
			_if_ = 19,
			_else_ = 20,
			_real_ = 21,
			_complex_ = 22,
			_sint_ = 23,
			_uint_ = 24,
			_bool_ = 25,
			_sin_ = 26,
			_cos_ = 27,
			_exp_ = 28,
			_ln_ = 29,
			_log_ = 30,
			_sqrt_ = 31,
			_pow_ = 32,
			_spaces_ = 33,
			_enters_ = 34,
			_tab_ = 35,
			_semicolon_ = 36,
			_colon_ = 37,
			_dot_ = 38,
			_comma_ = 39,
			_braceL_ = 40,
			_braceR_ = 41,
			_left_ = 42,
			_right_ = 43,
			_squareL_ = 44,
			_squareR_ = 45,
			_angleL_ = 46,
			_angleR_ = 47,
			_anntationS_ = 48,
			_anntationM_ = 49,
			_multi_ = 50,
			_div_ = 51,
			_sub_ = 52,
			_add_ = 53,
			_assign_ = 54
		};
		enum group
		{
			_id___ = 1,
			_number___ = 2,
			_string___ = 3,
			_macro___ = 4,
			_instruct___ = 5,
			_reserved___ = 6,
			_type___ = 7,
			_function1___ = 8,
			_function2___ = 9,
			_format___ = 10,
			_division___ = 11,
			_braket___ = 12,
			_anntation___ = 13,
			_operatmd___ = 14,
			_operatas___ = 15,
			_assignments___ = 16
		};
		static int next(int state, const char c);
		static int action(int state);
		static int GroupGet(int state);
	};
	struct NetPreG
	{
		enum type
		{
			accept = 0,
			error = 1,
			push = 2,
			reduce = 3
		};
		enum rules
		{
			all_all_ = 0,
			pretreat_meow_ = 1,
			//<DEF*>_first_ = 2,
			//<DEF*>_multi_ = 3,
			DEF_anntation_ = 4,
			DEF_anything_ = 5,
			DEF_include_ = 6,
			//[anntation]_anntationS_ = 7,
			//[anntation]_anntationM_ = 8,
			INCLUDE_include_ = 9,
			INCLUDE_include2_ = 10,
			MACRO_single_ = 11,
			MACRO_multi_ = 12,
			ANY_identifier_ = 13,
			ANY_number_ = 14,
			ANY_string_ = 15,
			ANY_instruct_ = 16,
			ANY_reserved_ = 17,
			ANY_type_ = 18,
			ANY_function1_ = 19,
			ANY_function2_ = 20,
			ANY_format_ = 21,
			ANY_division_ = 22,
			ANY_braket_ = 23,
			ANY_operatmd_ = 24,
			ANY_operatas_ = 25,
			ANY_assignments_ = 26,
			//[id]_id_ = 27,
			//[number]_integer_ = 28,
			//[number]_realC_ = 29,
			//[instruct]_forward_ = 30,
			//[instruct]_backward_ = 31,
			//[instruct]_sum_ = 32,
			//[reserved]_func_ = 33,
			//[reserved]_net_ = 34,
			//[reserved]_tensor_ = 35,
			//[reserved]_def_ = 36,
			//[reserved]_input_ = 37,
			//[reserved]_output_ = 38,
			//[reserved]_para_ = 39,
			//[reserved]_return_ = 40,
			//[reserved]_for_ = 41,
			//[reserved]_if_ = 42,
			//[reserved]_else_ = 43,
			//[type]_real_ = 44,
			//[type]_complex_ = 45,
			//[type]_sint_ = 46,
			//[type]_uint_ = 47,
			//[type]_bool_ = 48,
			//[function1]_sin_ = 49,
			//[function1]_cos_ = 50,
			//[function1]_exp_ = 51,
			//[function1]_ln_ = 52,
			//[function1]_log_ = 53,
			//[function1]_sqrt_ = 54,
			//[function2]_pow_ = 55,
			//[format]_spaces_ = 56,
			//[format]_enters_ = 57,
			//[format]_tab_ = 58,
			//[division]_semicolon_ = 59,
			//[division]_colon_ = 60,
			//[division]_dot_ = 61,
			//[division]_comma_ = 62,
			//[braket]_braceL_ = 63,
			//[braket]_braceR_ = 64,
			//[braket]_left_ = 65,
			//[braket]_right_ = 66,
			//[braket]_squareL_ = 67,
			//[braket]_squareR_ = 68,
			//[braket]_angleL_ = 69,
			//[braket]_angleR_ = 70,
			//[operatmd]_multi_ = 71,
			//[operatmd]_div_ = 72,
			//[operatas]_sub_ = 73,
			//[operatas]_add_ = 74,
			//[assignments]_assign_ = 75
		};
		enum nonterminal
		{
			_all_ = 0,
			_pretreat_ = 1,
			//_<DEF*>_ = 2,
			_DEF_ = 3,
			//_[anntation]_ = 4,
			_INCLUDE_ = 5,
			_MACRO_ = 6,
			_ANY_ = 7,
			//_[id]_ = 8,
			//_[number]_ = 9,
			//_[instruct]_ = 10,
			//_[reserved]_ = 11,
			//_[type]_ = 12,
			//_[function1]_ = 13,
			//_[function2]_ = 14,
			//_[format]_ = 15,
			//_[division]_ = 16,
			//_[braket]_ = 17,
			//_[operatmd]_ = 18,
			//_[operatas]_ = 19,
			//_[assignments]_ = 20
		};
		static const size_t StateCount;
		static const size_t NonTerminalCount;
		static const size_t TerminalCount;
		static const size_t RulesCount;
		static const int GOTO[77][21];
		static const int ACTION[77][55];
		static const int RulesToSymbol[76];
		static const int RulesLength[76];
		static const char* const RulesName[76];
		static const int Implicit[76];
	};



}



#endif // 